(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{485:function(t,e,n){"use strict";n.r(e);var a=n(20),r=Object(a.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h3",{attrs:{id:"javascript有几种数据类型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#javascript有几种数据类型"}},[t._v("#")]),t._v(" JavaScript有几种数据类型？")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("number、string、boolean、undefined、null、symbol、bigint、object\n")])])]),n("h3",{attrs:{id:"javascript最大安全数字与最小安全数字"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#javascript最大安全数字与最小安全数字"}},[t._v("#")]),t._v(" JavaScript最大安全数字与最小安全数字？")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("Number.MAX_SAFE_INTEGER、Number.MIN_SAFE_INTEGER\n")])])]),n("h3",{attrs:{id:"深拷贝与浅拷贝的区别"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#深拷贝与浅拷贝的区别"}},[t._v("#")]),t._v(" 深拷贝与浅拷贝的区别？")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("浅拷贝：只拷贝第一层，深层的依然是引用，改变深层会影响原对象\n深拷贝：每一层都拷贝了，改变数据不会影响原对象\n")])])]),n("h3",{attrs:{id:"闭包是什么"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#闭包是什么"}},[t._v("#")]),t._v(" 闭包是什么？")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("闭包是一个函数，是一个能让外部访问到函数内部的函数\n优点：使外部能访问内部，延长内部变量寿命\n缺点：滥用闭包造成内存泄漏\n")])])]),n("h3",{attrs:{id:"原型链是什么呀"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#原型链是什么呀"}},[t._v("#")]),t._v(" 原型链是什么呀？")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("原型链是一条引用的链，实例的隐式原型指向构造函数的显式原型，可以使用A instanceof B来判断B是否在A的原型链上。\n\nfunction Fn() {}// Fn为构造函数\nvar f1 = new Fn();//f1 是Fn构造函数创建出来的对象\nconsole.log(Fn.prototype) // {}\nconsole.log(typeof Fn.prototype)// object\nconsole.log(Fn.prototype.constructor)//[Function: Fn]\nconsole.log(f1.__proto__)// {}\n\n// 所有Fn.prototype.__proto__===Object.prototype\nconsole.log(typeof Object.prototype) //object\nconsole.log(Object.prototype.__proto__) //null\n")])])]),n("h3",{attrs:{id:"原型是什么-原型链是什么"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#原型是什么-原型链是什么"}},[t._v("#")]),t._v(" 原型是什么？原型链是什么？")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("什么是变量提升？函数提升？\n在js中只有两种作用域，全局作用域和函数作用域，在ES6之前，js是没有块级作用域。\nJavaScript 代码的执行分为两个阶段。第一个阶段在当前词法环境中注册所有的变量和函数声明，简单说就是，解析，解析完成之后，第二个阶段的 JavaScript 执行就开始了！\nJS中创建函数有两种方式：函数声明式和函数字面量式。只有函数声明才存在函数提升。\nJavaScript 仅提升声明，而不提升初始化。如果你先使用的变量，再声明并初始化它，变量的值将是 undefined。\n1:所有的声明都会提升到作用域的最顶上去。\n2:同一个变量只会声明一次，其他的会被忽略掉。\n3:函数声明的优先级高于变量申明的优先级，并且函数声明和函数定义的部分一起被提升。\n")])])]),n("h3",{attrs:{id:"什么是变量提升-什么是函数提升"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么是变量提升-什么是函数提升"}},[t._v("#")]),t._v(" 什么是变量提升？什么是函数提升？")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("isNaN 与 Number.isNaN的区别？\n// Number.isNaN不存在类型转换的行为。\nconsole.log(Number('测试')) // NaN\nconsole.log(isNaN('测试')) //true\nconsole.log(Number.isNaN('测试')) //false\n解决遍历对象时，把原型上的属性遍历出来了咋办？\nhasOwnProperty() //方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性（也就是，是否有指定的键）\n")])])]),n("h3",{attrs:{id:"valueof-与-tostring"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#valueof-与-tostring"}},[t._v("#")]),t._v(" valueOf 与 toString？")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("toString：正常情况下、偏向于显示、对象、字符转换\nvalueOf：比较偏向于计算、数字、运算操作符转换\n")])])]),n("h3",{attrs:{id:"栈内存和堆内存的区别"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#栈内存和堆内存的区别"}},[t._v("#")]),t._v(" 栈内存和堆内存的区别")]),t._v(" "),n("table",[n("tr",[n("th",[t._v("栈内存")]),t._v(" "),n("th",[t._v("堆内存")])]),t._v(" "),n("tr",[n("td",[t._v("存储基础数据类型")]),t._v(" "),n("td",[t._v("存储引用类型")])]),t._v(" "),n("tr",[n("td",[t._v("按值访问")]),t._v(" "),n("td",[t._v("按引用访问")])]),t._v(" "),n("tr",[n("td",[t._v("存储的值大小固定")]),t._v(" "),n("td",[t._v("存储的值大小不定")])]),t._v(" "),n("tr",[n("td",[t._v("由系统自动分配内存空间")]),t._v(" "),n("td",[t._v("由代码进行指定分配")])]),t._v(" "),n("tr",[n("td",[t._v("空间小运行效率高")]),t._v(" "),n("td",[t._v("空间大、运行效率相对较低")])]),t._v(" "),n("tr",[n("td",[t._v("先进后出、后进先出\t无序存储，")]),t._v(" "),n("td",[t._v("根据引用直接获取引用数据类型")])])]),t._v("\t\n### 除了基本类型的就是引用类型了\n\tObject 类型。细分的话，有：Object、Array、Date、RegExp、Function\n\t检测\n### JavaScript变量在内存中具体存储形式？\n\t// 基本数据类型：存在栈内存里\n\t// 引用数据类型：指针存栈内存，指向堆内存中一块地址，内容存在堆内存中,\n\t// JavaScript不允许直接访问堆内存中的位置，因此操作对象时，实际操作对象的引用\n\t// 基本类型发生复制行为\n\tlet a1 = 0; a2 = \"this is string\" // 栈内存\n\tlet b = { x: 10 }; // 变量b存在于栈中，{ x: 10 }作为对象存在于堆中\n\t// 访问堆内存中的引用数据类型时,从栈中获取该对象的地址引用,再从堆内存中取得我们需要的数据.\n\t// 引用类型发生复制行为\n\tlet a = { x: 10, y: 20 };\n\tlet b2 = a;\n\tb2.x = 5;\n\tconsole.log(a.x); // 5\n\t// 引用类型的复制，同样为新的变量b2分配一个新的值，保存在栈内存中，不同的是，这个值仅仅是引用类型的一个地址指针\n\t// 他们两个指向同一个值，也就是地址指针相同，在堆内存中访问到的具体对象实际上是同一个\n\t// 因此改变b2.x时，a.x也发生了变化，这就是引用类型的特性\n### 讲一讲JavaScript的装箱和拆箱？\n\t// 装箱：把基本数据类型转化为对应的引用数据类型的操作\n\t// 看以下代码，s1只是一个基本数据类型，他是怎么能调用indexOf的呢？\n\tconst s1 = 'Sunshine_Lin'\n\tconst index = s1.indexOf('_')\n\tconsole.log(index) // 8\n\t// 原来是JavaScript内部进行了装箱操作  \n\tvar temp = new String('Sunshine_Lin') // 创建String类型的一个实例；\n\tconst index2 = temp.indexOf('_') // 在实例上调用指定的方法；\n\ttemp = null // 销毁这个实例；\n\tconsole.log(index2) // 8\n\t//拆箱：将引用数据类型转化为对应的基本数据类型的操作, 通过valueOf或者toString方法实现拆箱操作\n\tvar objNum = new Number(123);  \n\tvar objStr =new String(\"123\");   \n\tconsole.log( typeof objNum ); //object\n\tconsole.log( typeof objStr ); //object \n\tconsole.log( typeof objNum.valueOf() ); //number\n\tconsole.log( typeof objStr.valueOf() ); //string\n\tconsole.log( typeof objNum.toString() ); // string \n\tconsole.log( typeof objStr.toString() ); // string\n### null和undefined的异同点有哪些？\n\t1.相同点\n\t    都是空类型\n\t    转布尔值都是false，都是假值\n\t    null == undefined 为 true\n\t2.不同点\n\t    typeof，前者为object，后者为undefined\n\t    null转数字为0，undefined转数字为NaN\n\t    null === undefined 为 false\n### 如何判断数据类型？\n\t1.typeof：能判断string、number、undefined、boolean、function、object（null是object）\n\t2.Object.prototype.toString.call()：能判断大部分数据类型\n\t3.instanceOf 用来判断某个构造函数的 prototype 属性所指向的对象是否存在于另外一个要检测对象的原型链上\n### 为什么typeof null 是object？\n\t不同数据类型底层都是用二进制来表示的，二进制前三位为000则会被判断为object，而null二进制全是0，所以被判断成object\n"),n("h3",{attrs:{id:"显示转化和隐式转换"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#显示转化和隐式转换"}},[t._v("#")]),t._v(" 显示转化和隐式转换")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("显示的转换数据类型主要通过JS定义的数据转换方法。\n转型函数有Boolean()、Number()、parseInt()、parseFloat()、toString()\n隐式的数据转换，在JS中有一些操作符或者语句也会进行数据转换。比如if语句将条件转换为布尔类型值。\n递增和递减操作符(++,--),逻辑非操作符(!) 与 比较操作符(<,>,=),判断语句(if，do-while，while)\nJavaScript的隐式转换规则？\n转string类型：+（字符串连接符）\n转number类型：++/--(自增自减运算符) + - * / %(算术运算符) > < >= <= == != === !== (关系运算符)\n转boolean：!（逻辑非运算符)\n")])])]),n("h3",{attrs:{id:"双等号左右两边的转换规则"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#双等号左右两边的转换规则"}},[t._v("#")]),t._v(" 双等号左右两边的转换规则？")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("null == undefined 为 true\n1.如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false转换为0，而true转换为1；\n2.如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值\n3.如果一个操作数是对象，另一个操作数不是，则调用对象的toString()方法，用得到的基本类型值按照前面的规则进行比较\n")])])]),n("h3",{attrs:{id:"与-的区别"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#与-的区别"}},[t._v("#")]),t._v(" == 与 === 的区别？")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("==：比较过程会进行隐式转换\n===：值相同，类型相同才会为true\n")])])]),n("h3",{attrs:{id:"undefined-undefined-为什么是-false"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#undefined-undefined-为什么是-false"}},[t._v("#")]),t._v(" undefined >= undefined 为什么是 false ？")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("隐式转换，变成NaN >= NaN，NaN不等于自身也不大于自身\n")])])]),n("h3",{attrs:{id:"null-null-为什么是-true"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#null-null-为什么是-true"}},[t._v("#")]),t._v(" null >= null 为什么是 true？")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("隐式转换，变成0 >= 0，为true\n")])])]),n("h3",{attrs:{id:"为什么是-true"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#为什么是-true"}},[t._v("#")]),t._v(" [] == ![] 为什么是 true ？")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("第一步：转为[] == false\n第二步：转为[] == 0\n第三步：转为'' == 0\n第四步：转为0 == 0\n")])])]),n("h3",{attrs:{id:"_0-1-0-2-0-3-对吗"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_0-1-0-2-0-3-对吗"}},[t._v("#")]),t._v(" 0.1 + 0.2 === 0.3，对吗？")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("存在精度丢失问题，由于有些小数无法用二进制表示，所以只能取近似值，\nconsole.log(0.1 + 0.2 === 0.3) // false\nconsole.log((0.1*10+0.2*10)/10 ===0.3) //true\nconsole.log(parseFloat((0.1+0.2).toFixed(10)) ===0.3) //true\n")])])]),n("h3",{attrs:{id:"什么是匿名函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么是匿名函数"}},[t._v("#")]),t._v(" 什么是匿名函数？")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("匿名函数，就是没有名字的函数，比如：\n(function(x, y){\n    alert(x + y);  \n})(2, 3)\n")])])]),n("h3",{attrs:{id:"绑定点击事件有几种方式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#绑定点击事件有几种方式"}},[t._v("#")]),t._v(" 绑定点击事件有几种方式？")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("1.xxx.onclick = function (){}\n2.<xxx onclick=\"\"></xxx>\n3.xxx.addEventListener('click', function(){}, false)\n// addEventListener的第三个参数是干嘛的？决定事件是捕获阶段执行还是冒泡阶段执行，true：捕获，false：默认，冒泡\n")])])]),n("h3",{attrs:{id:"函数声明和函数表达式的区别"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#函数声明和函数表达式的区别"}},[t._v("#")]),t._v(" 函数声明和函数表达式的区别？")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("// 函数声明：享受函数提升\n// 函数表达式：归类于变量声明，享受变量提升\n// 函数提升优先级 > 变量提升优先级\nconsole.log(fun) // fun () {}\n// 函数表达式\nvar fun = function(name) {}\n// 函数声明\nfunction fun () {}\nconsole.log(fun) // fun (name) {}\n")])])]),n("h3",{attrs:{id:"javascript的事件流模型有哪些"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#javascript的事件流模型有哪些"}},[t._v("#")]),t._v(" JavaScript的事件流模型有哪些？")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("事件冒泡：由最具体的元素接收，并往上传播\n事件捕获：由最不具体的元素接收，并往下传播\nDOM事件流：事件捕获 -> 目标阶段 -> 事件冒泡\nAjax、Axios、Fetch有啥区别？\nAjax：是对XMLHttpRequest(XHR)的封装\nAxios：是基于Promise对XHR对象的封装\nFetch：是window的一个方法，基于Promise，与XHR无关，不兼容IE\nload、$(document).ready、DOMContentLoaded的区别？\n$(document).ready、DOMContentLoaded：DOM树构建完毕，但还没有请求静态资源\nload：静态资源请求完毕\n")])])]),n("h3",{attrs:{id:"如何阻止事件冒泡"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#如何阻止事件冒泡"}},[t._v("#")]),t._v(" 如何阻止事件冒泡？")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("function stopBubble(e) {\nif (e.stopPropagation) {\n    e.stopPropagation()\n} else {\n    window.event.cancelBubble = true;\n}\n}\n")])])]),n("h3",{attrs:{id:"如何阻止事件默认行为"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#如何阻止事件默认行为"}},[t._v("#")]),t._v(" 如何阻止事件默认行为？")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("function stopDefault(e) {\nif (e.preventDefault) {\n    e.preventDefault();\n} else {\n    window.event.returnValue = false;\n}\n}\n")])])]),n("h3",{attrs:{id:"什么是事件委托"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么是事件委托"}},[t._v("#")]),t._v(" 什么是事件委托？")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("当子元素都需要绑定相同事件时，可以将事件绑在父元素上，优点有：\n绑定在父元素，则只需绑定一次，节省性能\n后续新增的子元素也可以触发父元素绑定的事件\n如何实现数组去重？\nlet arr = [1, 2, 1,2,3]\nlet newArr = []\n// // 1. for循环\n// // 2. for循环 + indexOf / includes\n// for (let i = 0, l = arr.length; i < l; i++) {\n//   if (newArr.indexOf(arr[i]) === -1) {\n//     newArr.push(arr[i])\n//   }\n// }\n// // 3. forEach + includes / indexOf\n// arr.forEach(item => {\n//   if (!newArr.includes(item)) newArr.push(item)\n// })\n// 4. 基于对象处理\nlet obj = {}\nfor (let i = 0; i < arr.length; i++) {\nlet item = arr[i] // 如果对象中已经有该元素, 说明该元素是重复元素\nif (obj[item] !== undefined) { // 就把数组最后一位放在该位置, 相当于删掉了该元素\n    arr[i] = arr[arr.length - 1]     // 数组长度减1, 将最后一个元素去掉\n    arr.length-- // i减一, 保证下次循环从替换的元素开始\n    i--\n    // continue\n}\nobj[item] = item\n}\n// 5.Set\n// console.log([... new Set(arr)])\n// console.log(arr)\n")])])]),n("h3",{attrs:{id:"set与array的区别是什么"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#set与array的区别是什么"}},[t._v("#")]),t._v(" Set与Array的区别是什么？")]),t._v(" "),n("table",[n("tr",[n("th",[t._v("区别")]),t._v(" "),n("td",[t._v("判断有无元素")]),t._v(" "),n("td",[t._v("添加元素")]),t._v(" "),n("td",[t._v("删除元素")]),t._v(" "),n("td",[t._v("长度")]),t._v(" "),n("td",[t._v("清空")]),t._v(" "),n("td",[t._v("转换\t")]),t._v(" "),n("td",[t._v("遍历")]),t._v(" "),n("td",[t._v("去重")])]),t._v(" "),n("tr",[n("th",[t._v("Set")]),t._v(" "),n("td",[t._v("has")]),t._v(" "),n("td",[t._v("add")]),t._v(" "),n("td",[t._v("delete")]),t._v(" "),n("td",[t._v("size")]),t._v(" "),n("td",[t._v("clear")]),t._v(" "),n("td",[t._v("new Set(array)")]),t._v(" "),n("td",[t._v("forEach")]),t._v(" "),n("td",[t._v("有")])]),t._v(" "),n("tr",[n("th",[t._v("Array")]),t._v(" "),n("td",[t._v("index")]),t._v(" "),n("td",[t._v("push、unshift")]),t._v(" "),n("td",[t._v("splice、pop、shift")]),t._v(" "),n("td",[t._v("lenght")]),t._v(" "),n("td",[t._v("重新赋值[]")]),t._v(" "),n("td",[t._v("keys、value")]),t._v(" "),n("td",[t._v("无")]),t._v(" "),n("td",[t._v("无")])])]),t._v("\n### Map与Object的区别是什么？\n"),n("table",[n("tr",[n("th",[t._v("区别")]),t._v(" "),n("td",[t._v("设置属性")]),t._v(" "),n("td",[t._v("获取属性值")]),t._v(" "),n("td",[t._v("判断属性存在与否")]),t._v(" "),n("td",[t._v("删除元素")]),t._v(" "),n("td",[t._v("清空")]),t._v(" "),n("td",[t._v("转数组键值对")]),t._v(" "),n("td",[t._v("遍历")])]),t._v(" "),n("tr",[n("th",[t._v("Map")]),t._v(" "),n("td",[t._v("set")]),t._v(" "),n("td",[t._v("get")]),t._v(" "),n("td",[t._v("has")]),t._v(" "),n("td",[t._v("delete")]),t._v(" "),n("td",[t._v("clear")]),t._v(" "),n("td",[t._v("entries")]),t._v(" "),n("td",[t._v("自带forEach")])]),t._v(" "),n("tr",[n("th",[t._v("Obj")]),t._v(" "),n("td",[t._v("obj[key] = value")]),t._v(" "),n("td",[t._v("obj[key]")]),t._v(" "),n("td",[t._v("obj[key]")]),t._v(" "),n("td",[t._v("delete关键字")]),t._v(" "),n("td",[t._v("重新赋值{}")]),t._v(" "),n("td",[t._v("entries")]),t._v(" "),n("td",[t._v("无")])])])])}),[],!1,null,null,null);e.default=r.exports}}]);